import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import 'dart:io';
import 'package:path/path.dart';

class DatabaseHelper {
  static final _dbName = 'myDatabe.db';
  static final _dbVersion = 1;

  static final _tableName = 'myTable';
  static final columnId = '_id';
  static final columnName = 'name';

  //must be a singleton class
  DatabaseHelper.privateConstructor();
  //or
  //DatabaseHelper._();
  static final DatabaseHelper instance = DatabaseHelper.privateConstructor();

  //create a null database
  static Database _database;
  //this is a getter of our private database
  Future<Database> get database async {
    //check if the database is not null then we'll return it and the function will break
    if (_database != null) return _database;
    //else if it's null then we'll initialize it
    _database = await _initiateDatabase();
    // and then we will return it
    return _database;
  }

  Future _initiateDatabase() async {
    // Get the directory path for both Android and iOS to store database.
    //Directory is a class in dart.io
    //we use the fuction getApp.. from the path_provider package to get us the path to the private files
    Directory directory = await getApplicationDocumentsDirectory();
    //join (add) the directory path to our dbname and returns the final path
    String path = join(directory.path, _dbName);
    //now we will initiate our database by giving it a name, a version and an oncreate function
    return await openDatabase(path, version: _dbVersion, onCreate: _onCreate);
  }

  Future _onCreate(Database db, int version) {
    //and Nooow : sql time
    //we create a new table called _tableName, this table has 2 columns, id and name
    db.execute('''
      CREATE TABLE $_tableName(
        $columnId INTEGER PRIMARY KEY,
        $columnName TEXT NOT NULL
      )
      ''');
  }

  //Our data will be written as a map
  // {
  //   "id" : 2,
  //   "name" : "hanane"
  // }

  //We will create function CRUD functions to use them wherever we want

  //Create (insert) a row
  //this function takes a row (the row we want to insert) as an argument, a row has a type of Map<String, dynamic>
  //and returns a futur int (the id of the inserted row)
  Future<int> insert(Map<String, dynamic> row) async {
    //db is our database, we get it using the getter 'database' from our instance of the class DatabaseHelper
    Database db = await instance.database;
    //insert is a function from the sqflite package, it requires the table name and the row we want to insert
    //and returns the id of the inserted row (generated by the sqflite itself, the id is unique)
    var added = await db.insert(_tableName, row);
    print(added);
    return added;
  }

  //Read (get all queries) the table
  //this function doesn't take any argument and returns a list of rows (in form of map)
  Future<List<Map<String, dynamic>>> queryAll() async {
    Database db = await instance.database;
    //query is the sqflite fct that reads the table, so it required the name of the table
    var all = await db.query(_tableName);
    print(all);
    return all;
  }

  //update a row
  //this fct returns an int (the number of rows updated)
  //it takes as an argument the row withe values we want to update
  Future<int> update(Map<String, dynamic> row) async {
    Database db = await instance.database;
    //getting the id of the row we want to update
    int id = row[columnId];
    //the update fct from the sqflite package takes as arguments: the name of the table,
    //the row we want to update, the conditions (we may have  where: '$columnId = ? && $columnName = ?')
    //and the whereArgs is a list of args used in the where (instead of '?') so we may have whereArgs: [id,name]
    return await db
        .update(_tableName, row, where: '$columnId = ?', whereArgs: [id]);
  }

  //delete a row
  //this fct returns an int (the number of rows deleted)
  //it takes as an argument the row we want to delete
  Future<int> delete(int id) async {
    Database db = await instance.database;
    //the delete fct from the sqflite package takes as arguments: the name of the table,
    //the conditions (we may have  where: '$columnId = ? && $columnName = ?')
    //and the whereArgs is a list of args used in the where (instead of '?') so we may have whereArgs: [id,name]
    return await db.delete(_tableName, where: '$columnId = ?', whereArgs: [id]);
  }

  // Get number of rows in database
  Future<int> getCount() async {
    Database db = await instance.database;
    List<Map<String, dynamic>> x =
        await db.rawQuery('SELECT COUNT (*) from $_tableName');
    int result = Sqflite.firstIntValue(x);
    return result;
  }
}
